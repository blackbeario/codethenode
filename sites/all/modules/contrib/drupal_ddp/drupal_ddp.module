<?php

/**
 * @file
 * Drupal DDP Module configuration and settings.
 */

/**
 * Implements hook_menu().
 */
function drupal_ddp_menu() {
  $items['admin/config/development/drupal-ddp'] = array(
    'title' => 'Drupal DDP Settings',
    'description' => 'Settings related to Drupal DDP module.',
    'page callback' => 'drupal_get_form',
    'page arguments'  => array('_drupal_ddp_form'),
    'access arguments' => array('access drupal ddp'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function drupal_ddp_permission() {
  return array(
    'access drupal ddp' => array(
      'title' => t('Access Drupal DDP Settings'),
      'description' => t('Allow users to access Drupal DDP Settings'),
    ),
  );
}

/**
 * Settings form for Drupal DDP module.
 *
 * @return array
 *   Settings form renderable array.
 */
function _drupal_ddp_form() {
  $form = array();
  $form['drupal_ddp_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Drupal DDP Settings'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['drupal_ddp_settings']['drupal_ddp_settings_ddp_server_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Drupal DDP node server URL'),
    '#default_value' => variable_get('drupal_ddp_settings_ddp_server_url',
                                     'http://localhost:8080'),
    '#description' => t('Enter the full URL to your node sever (ddp.js).
      Make sure to enter the port that the node server is listening on.'),
  );
  $form['drupal_ddp_settings']['drupal_ddp_security_token'] = array(
    '#type' => 'textfield',
    '#title' => t('Simple Security Token'),
    '#default_value' => variable_get('drupal_ddp_security_token'),
    '#description' => t('Enter a simple security token.
      Enter this same token in your Meteor settings.json file.'),
  );

  $content_types = node_type_get_types();
  $use_with_ddp = $types = $sync_nodes = array();

  foreach ($content_types as $key => $type) {
    // Generate array of all content types.
    $types[$key] = $type->name;

    // Get the keys array keys of content types that can be
    // be used with Drupal DDP.
    if (variable_get('drupal_ddp_enabled_' . $key, 0) == 1) {
      $use_with_ddp[] = $key;
      $sync_nodes[$key] = $type->name;
    }
  }

  $form['drupal_ddp_settings']['drupal_ddp_settings_enabled_types'] = array(
    '#title' => t('Content Types'),
    '#type' => 'checkboxes',
    '#description' => t('Select the content types to use with Drupal DDP.'),
    '#options' => $types,
    '#default_value' => $use_with_ddp,
  );

  $form['drupal_ddp_settings']['sync'] = array(
    '#type' => 'fieldset',
    '#title' => t('Sync existing content with Meteor'),
    '#description' => t('Push existing data over to Meteor.
                         Make sure that the DDP server &
                         your Meteor app are running.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['drupal_ddp_settings']['sync']['nodes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Nodes'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  $form['drupal_ddp_settings']['sync']['nodes']['sync_content_type'] = array(
    '#title' => t('Sync a Content Type'),
    '#type' => 'radios',
    '#options' => $sync_nodes,
  );
  $form['drupal_ddp_settings']['sync']['nodes']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Sync Nodes'),
    '#submit' => array('drupal_ddp_sync_existing_nodes'),
  );

  // Load list of Taxonomies.
  $taxonomies = taxonomy_get_vocabularies();
  $sync_taxonomies = array();
  foreach ($taxonomies as $taxonomy) {
    $sync_taxonomies[$taxonomy->machine_name] = $taxonomy->name;
  }

  $form['drupal_ddp_settings']['sync']['taxonomies'] = array(
    '#type' => 'fieldset',
    '#title' => t('Taxonomies'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['drupal_ddp_settings']['sync']['taxonomies']['sync_vocab'] = array(
    '#title' => t('Sync Taxonomy Vocabulary'),
    '#type' => 'radios',
    '#options' => $sync_taxonomies,
  );
  $form['drupal_ddp_settings']['sync']['taxonomies']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Sync Taxonomy'),
    '#submit' => array('drupal_ddp_sync_existing_taxonomies'),
  );

  $form['#submit'][] = '_drupal_ddp_settings_submit';

  return system_settings_form($form);
}

/**
 * Custom submit handler for _drupal_ddp_form.
 *
 * Sets variables for each content type that
 * is to be used with Drupal DDP.
 *
 * @param array $form
 *   The form being submitted.
 * @param array $form_state
 *   The current state of the form being submitted.
 */
function _drupal_ddp_settings_submit(array $form, array &$form_state) {
  $use_with_ddp = $form_state['values']['drupal_ddp_settings_enabled_types'];

  // If Content type is check to be used with Drupal DDP,
  // set the correct variable value.
  foreach ($use_with_ddp as $key => $val) {
    if (!empty($val) || $val != 0) {
      variable_set('drupal_ddp_enabled_' . $key, 1);
    }
    else {
      variable_set('drupal_ddp_enabled_' . $key, 0);
    }
  }
}

/**
 * Implements hook_entity_insert().
 *
 * Send content to Meteor on insert.
 */
function drupal_ddp_entity_insert($entity, $type) {
  switch ($type) {
    case 'node':
      // Set the ddp_type to 'node'.
      $entity->ddp_type = 'node';
      // Send post data to our ddp node server.
      if (drupal_ddp_use_with_ddp($entity->type)) {
        drupal_ddp_send_content($entity);
      }
      break;

    case 'taxonomy_term':
      // Set the ddp_type to 'taxonomy' and
      // also set 'is_new' to TRUE since taxonomies
      // don't include that flag on insert.
      $entity->ddp_type = 'taxonomy';
      $entity->is_new = TRUE;
      drupal_ddp_send_content($entity);
      break;
  }
}

/**
 * Implements hook_entity_update().
 *
 * Send content to Meteor on update.
 */
function drupal_ddp_entity_update($entity, $type) {
  switch ($type) {
    case 'node':
      // Set the ddp_type to 'node'.
      $entity->ddp_type = 'node';
      // Send post data to our ddp node server.
      if (drupal_ddp_use_with_ddp($entity->type)) {
        drupal_ddp_send_content($entity);
      }
      break;

    case 'taxonomy_term':
      // Set the ddp_type to 'taxonomy'.
      $entity->ddp_type = 'taxonomy';
      drupal_ddp_send_content($entity);
      break;
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Send content to Meteor on delete.
 */
function drupal_ddp_entity_delete($entity, $type) {
  // Set 'delete_content' flag to be used in Meteor.
  $entity->delete_content = TRUE;

  switch ($type) {
    case 'node':
      // Set the ddp_type to 'node'.
      $entity->ddp_type = 'node';
      // Send post data to our ddp node server.
      if (drupal_ddp_use_with_ddp($entity->type)) {
        drupal_ddp_send_content($entity);
      }
      break;

    case 'taxonomy_term':
      // Set the ddp_type to 'taxonomy'.
      $entity->ddp_type = 'taxonomy';
      drupal_ddp_send_content($entity);
      break;
  }
}

/**
 * Checks if content type is set to be used with Drupal DDP.
 *
 * @param string $content_type
 *   String value of content type.
 *
 * @return bool
 *   Returns TRUE if the $content_type can be
 *   used with drupal_ddp.
 */
function drupal_ddp_use_with_ddp($content_type) {
  $content_types = node_type_get_types();
  $use_with_ddp = array();

  // If Drupal DDP is enabled for a content type, save that content type to an
  // array.
  foreach ($content_types as $key => $type) {
    if (variable_get('drupal_ddp_enabled_' . $key, 0) == 1) {
      $use_with_ddp[] = $key;
    }
  }

  return in_array($content_type, $use_with_ddp) ? TRUE : FALSE;
}


/**
 * Enables a node to be sent to node server.
 *
 * @param object $content
 *   An entity object.
 */
function drupal_ddp_send_content($content) {
  $ddp_client_url = variable_get(
    'drupal_ddp_settings_ddp_server_url',
    'http://localhost:8080'
  );

  if ($content->ddp_type == 'node') {
    // Load the node.
    // This gets around an issue of cached data
    // being returned by restws.
    entity_get_controller('node')->resetCache(array($content->nid));

    // Get json from restws.
    $format = restws_format('json');
    $name = 'node';
    $id = $content->nid;
    $op = 'view';

    $json_string = drupal_ddp_handle_request($op, $format, $name, $id);
    $node = json_decode($json_string['string']);

    // Set ddp_type = node.
    $node->ddp_type = 'node';

    // If node is new, set is_new to TRUE
    // on the loaded node.
    if (isset($content->is_new) && ($content->is_new)) {
      $node->is_new = TRUE;
    }

    // If node has been deleted, set delete_node to TRUE.
    if (isset($content->delete_content) && ($content->delete_content)) {
      $node->delete_content = TRUE;
    }

    $content = $node;
  }

  // If a security phrase is set, add it to json object.
  $security_phrase = variable_get('drupal_ddp_security_token');
  $send_security = '';
  if (!empty($security_phrase)) {
    $send_security = '"simple_security": "' . $security_phrase . '", ';
  }

  // Create json document with data.
  $data = '{' . $send_security . '"content":' . json_encode($content) . '}';

  $options = array(
    'method' => 'POST',
    'data' => $data,
    'headers' => array('Content-Type' => 'application/json; charset=UTF-8'),
  );
  drupal_http_request($ddp_client_url, $options);
}

/**
 * Implements hook_form_alter().
 *
 * Adds custom fieldset to the node form, and attach ajax behaviour for vertical
 * panels to update the settings description.
 *
 * @see drupal_ddp.js
 */
function drupal_ddp_form_node_type_form_alter(&$form, $form_state) {
  // Only include on node add/edit forms.
  if (isset($form['type'])) {

    // Create a fieldset that will be included in the vertical tab.
    $form['drupal_ddp'] = array(
      '#type' => 'fieldset',
      '#title' => t('Drupal DDP'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      // The #group value must match the name of the vertical tabs element.
      // In most cases, this is 'additional_settings'.
      '#group' => 'additional_settings',
      '#attributes' => array(
        'class' => array('drupal-ddp-node-type-settings-form'),
      ),
      // Vertical tabs provide its most usable appearance when they are used to
      // include a summary of the information contained in the fieldset. To do
      // this, we attach additional JavaScript to handle changing the summary
      // when form settings are changed.
      '#attached' => array(
        'js' => array(
          'vertical-tabs' => drupal_get_path('module', 'drupal_ddp') . '/drupal_ddp.js',
        ),
      ),
    );

    // The form elements below provide a demonstration of how a fieldset
    // summary can be displayed in a collapsed tab.
    //
    // This checkbox is used to show or hide the custom settings form using
    // javascript (altering states of a container defined later).
    $form['drupal_ddp']['drupal_ddp_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use this content type with Drupal DDP'),
      '#default_value' => variable_get('drupal_ddp_enabled_' . $form['#node_type']->type, 0),
    );
  }
}


/**
 * Handles a request and returns it as a variable instead of printing it.
 *
 * Modified from restws_handle_request() in restws.module.
 */
function drupal_ddp_handle_request($op, $format, $resource_name, $id = NULL, $payload = NULL) {
  if ($resource = restws_resource_controller($resource_name)) {
    // Allow other modules to change the web service request or react upon it.
    $request = array(
      'op' => &$op,
      'format' => &$format,
      'resource' => &$resource,
      'id' => &$id,
      'payload' => &$payload,
    );
    drupal_alter('restws_request', $request);

    // Since there is no access callback for query we need to use view.
    $access_op = $op == 'query' ? 'view' : $op;
    $return = array();

    try {
      $method = $op . 'Resource';
      if ($op == 'create') {
        $return['string'] = $format->$method($resource, $payload);
        $return['header'] = array('Status', '201 Created');
      }
      elseif ($op == 'query') {
        if (!$resource instanceof RestWSQueryResourceControllerInterface) {
          throw new RestWSException('Quering not available for this resources', 501);
        }
        $return['string'] = $format->$method($resource, $payload);
      }
      else {
        $return['string'] = $format->$method($resource, $id, $payload);
      }
      $return['header'] = array('Content-Type', $format->mimeType());
    }
    catch (RestWSException $e) {
      $return['errors'] = check_plain($e->getHTTPError()) . ': ' . check_plain($e->getMessage());
      $return['header'] = array('Status', $e->getHTTPError());
      watchdog('drupal_ddp', $return['errors'], NULL, WATCHDOG_WARNING);
    }

    return $return;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_restws_response_alter().
 *
 * Alter the outgoing response.
 * Related issue https://drupal.org/node/2024603.
 */
function drupal_ddp_restws_response_alter(&$response, $function, $format_name, $resource_controller) {
  // Specific modifications based common request type.
  if (($function == 'viewResource' || $function == 'queryResource') && $format_name == 'json') {
    // Query response is nested, direct access is not.
    if ($function == 'queryResource') {
      foreach ($response['list'] as &$object) {
        drupal_ddp_restws_deep_load($object);
      }
    }
    else {
      drupal_ddp_restws_deep_load($response);
    }
  }
}

/**
 * Callback to perform deep load on a base entity.
 *
 * We're performing a deep-reference-load on referenced
 * files and taxonomy fields in order to get the data for
 * those fields rather than a resource callback.
 *
 * @param array $response
 *   Response about to be sent back for the RestWS query.
 */
function drupal_ddp_restws_deep_load(array &$response) {
  // Build list of allowed entity types to deep pull down.
  $allowed = array('taxonomy_term', 'file');

  // Allow for deep loading of resources.
  foreach ($response as $key => &$val) {
    // Check for a single resource verses many.
    if (is_array($val) && isset($val[0]['id'])) {
      // Loop through items loading them in.
      foreach ($val as &$item) {
        if (in_array($item['resource'], $allowed)) {
          // Load the entity.
          $entity = entity_load_single($item['resource'], $item['id']);
          // Ensure they can view this specific item.
          if (entity_access('view', $item['resource'], $entity)) {
            // Create a meta wrapper to act on for entity.
            $wrapper = entity_metadata_wrapper($item['resource'], $entity);
            // Filter out these values.
            $wrap = restws_property_access_filter($wrapper);
            $eary = (array) $entity;
            foreach ($eary as $property => $value) {
              // Value needs to be removed as it didn't pass wrapper validation.
              if (!isset($wrap[$property])) {
                unset($eary[$property]);
              }
            }
            // Add values based on wrapper passing correctly.
            $item = $eary;
          }
        }
      }
    }
    elseif (is_array($val) && isset($val[0]['file'])) {
      // Loop through items loading them in.
      foreach ($val as &$item) {
        if (in_array($item['file']['resource'], $allowed)) {
          // Load the entity.
          $entity = entity_load_single($item['file']['resource'], $item['file']['id']);
          $file_url = file_create_url($entity->uri);

          // Ensure they can view this specific item.
          if (entity_access('view', $item['file']['resource'], $entity)) {
            // Create a meta wrapper to act on for entity.
            $wrapper = entity_metadata_wrapper($item['file']['resource'], $entity);
            // Filter out these values.
            $wrap = restws_property_access_filter($wrapper);

            $eary = (array) $entity;
            foreach ($eary as $property => $value) {
              // Value needs to be removed as it didn't pass wrapper validation.
              if (!isset($wrap[$property])) {
                unset($eary[$property]);
              }
            }
            // Add file URL to resource.
            $eary['url'] = $file_url;
            // Add values based on wrapper passing correctly.
            $item['file'] = $eary;
          }
        }
      }
    }
    elseif (is_array($val) && isset($val['id'])) {
      if (in_array($val['resource'], $allowed)) {
        // Load the entity.
        $entity = entity_load_single($val['resource'], $val['id']);
        // Ensure they can view this specific item.
        if (entity_access('view', $val['resource'], $entity)) {
          // Create a meta wrapper to act on for entity.
          $wrapper = entity_metadata_wrapper($val['resource'], $entity);
          // Filter out fields.
          $wrap = restws_property_access_filter($wrapper);
          // Typecast entity as array for property evaluation.
          $eary = (array) $entity;
          foreach ($eary as $property => $value) {
            // Value needs to be removed as it didn't pass wrapper validation.
            if (!isset($wrap[$property])) {
              unset($eary[$property]);
            }
          }
          // Add values based on wrapper passing correctly.
          $val = $eary;
        }
      }
    }
  }
}

/**
 * Get all nids for a given content type.
 *
 * @return array
 *   Returns array of node ids for given content type.
 */
function drupal_ddp_get_all_nids_of_type($content_type) {
  $result = db_query("SELECT nid FROM node WHERE type = :s", array(':s' => $content_type));
  $nids = array_keys($result->fetchAllAssoc('nid'));

  return $nids;
}

/**
 * Sync existing node data with meteor app.
 */
function drupal_ddp_sync_existing_nodes($form, &$form_state) {
  // If value is array, then no value was chosen.
  $content_type_to_sync = $form_state['values']['sync_content_type'];
  if (empty($content_type_to_sync)) {
    drupal_set_message(t('No content types were chosen.'), 'error');
    return;
  }

  // Reset counter for debug information.
  $_SESSION['http_request_count'] = 0;

  // Execute the function named batch_drupal_ddp_sync_nodes.
  $batch = drupal_ddp_batch_sync_nodes($content_type_to_sync);
  batch_set($batch);
}

/**
 * Sync existing taxonomy term data with meteor app.
 */
function drupal_ddp_sync_existing_taxonomies($form, &$form_state) {
  // If value is array, then no value was chosen.
  $vocab_name = $form_state['values']['sync_vocab'];
  if (empty($vocab_name)) {
    drupal_set_message(t('No content types were chosen.'), 'error');
    return;
  }
  $vocab = taxonomy_vocabulary_machine_name_load($vocab_name);

  // Reset counter for debug information.
  $_SESSION['http_request_count'] = 0;

  // Execute the function named batch_drupal_ddp_sync_nodes.
  $batch = drupal_ddp_batch_sync_taxonomy($vocab);
  batch_set($batch);
}

/**
 * Batch Definition: Load and save all nodes with particular type.
 */
function drupal_ddp_batch_sync_nodes($content_type) {
  $nids = drupal_ddp_get_all_nids_of_type($content_type);
  $num_operations = count($nids);
  drupal_set_message(
    t(
      'Syncing @num nodes of "@content_type"',
      array(
        '@num' => $num_operations,
        '@content_type' => $content_type,
      )
    )
  );

  $operations = array();
  // Each operation in the operations array means at least one new HTTP request,
  // running Drupal from scratch to accomplish the operation. If the operation
  // returns with $context['finished'] != TRUE, then it will be called again.
  // In this example, $context['finished'] is always TRUE.
  for ($i = 0; $i < $num_operations; $i++) {
    // Each operation is an array consisting of
    // - The function to call.
    // - An array of arguments to that function.
    $operations[] = array(
      '_drupal_ddp_batch_node_operation',
      array(
        $nids[$i],
        t('(Operation @operation)', array('@operation' => $i + 1)),
      ),
    );
  }
  $batch = array(
    'operations' => $operations,
    'finished' => 'drupal_ddp_batch_finished',
  );
  return $batch;
}

/**
 * Batch Definition: Load and save all terms in a vocab.
 */
function drupal_ddp_batch_sync_taxonomy($vocab) {
  $terms = taxonomy_get_tree($vocab->vid);
  $num_operations = count($terms);
  drupal_set_message(t('Syncing @num terms in "@vocab"', array('@num' => $num_operations, '@vocab' => $vocab->name)));

  $operations = array();
  // Each operation in the operations array means at least one new HTTP request,
  // running Drupal from scratch to accomplish the operation.
  for ($i = 0; $i < $num_operations; $i++) {
    // Each operation is an array consisting of
    // - The function to call.
    // - An array of arguments to that function.
    $operations[] = array(
      '_drupal_ddp_batch_taxonomy_operation',
      array(
        $terms[$i],
        t('(Operation @operation)', array('@operation' => $i + 1)),
      ),
    );
  }
  $batch = array(
    'operations' => $operations,
    'finished' => 'drupal_ddp_batch_finished',
  );
  return $batch;
}

/**
 * Batch operation for syncing nodes.
 *
 * Load a node and save it to invoke hook_entity_update().
 */
function _drupal_ddp_batch_node_operation($nid, $operation_details, &$context) {
  $node = node_load($nid, NULL, TRUE);

  // Store some results for post-processing in the 'finished' callback.
  // The contents of 'results' will be available as $results in the
  // 'finished' function.
  $context['results'][] = $node->nid . ' : ' . check_plain($node->title);

  // Message displayed under the progressbar.
  $context['message'] = t('Syncing node "@title"', array('@title' => $node->title)) . ' ' . $operation_details;

  // Save node.
  node_save($node);

  _drupal_ddp_update_http_requests();
}

/**
 * Batch operation for syncing terms.
 *
 * Save a taxonomy term to invoke hook_entity_update().
 */
function _drupal_ddp_batch_taxonomy_operation($term, $operation_details, &$context) {
  // Store some results for post-processing in the 'finished' callback.
  // The contents of 'results' will be available as $results in the
  // 'finished' function.
  $context['results'][] = $term->tid . ' : ' . check_plain($term->name);

  // Message displayed under the progressbar.
  $context['message'] = t('Syncing term "@title"', array('@title' => $term->name)) . ' ' . $operation_details;

  // Save Term.
  taxonomy_term_save($term);

  _drupal_ddp_update_http_requests();
}

/**
 * Batch 'finished' callback.
 *
 * Used by drupal_ddp_batch_sync_nodes and drupal_ddp_batch_sync_taxonomy.
 */
function drupal_ddp_batch_finished($success, $results, $operations) {
  if ($success) {
    // Here we could do something meaningful with the results.
    // We just display the number of nodes we processed...
    drupal_set_message(t('@count items synced.', array('@count' => count($results))));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    drupal_set_message(
      t('An error occurred while processing @operation with arguments : @args',
        array(
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        )
      )
    );
  }
}

/**
 * Utility function to increment HTTP requests in a session variable.
 */
function _drupal_ddp_update_http_requests() {
  $_SESSION['http_request_count']++;
}

/**
 * Utility function to count the HTTP requests in a session variable.
 *
 * @return int
 *   Number of requests.
 */
function _drupal_ddp_get_http_requests() {
  return !empty($_SESSION['http_request_count']) ? $_SESSION['http_request_count'] : 0;
}
